/**
 * soapembed.c -- a way to embed the SOAP gateway into a C program.
 * $Id: soapembed.c,v 1.2 2004/04/19 05:39:09 bsittler Exp $
 **/

/**
 * Copyright 2000-2004 KnowNow, Inc.  All rights reserved.
 *
 * @KNOWNOW_LICENSE_START@
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the KnowNow, Inc., nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * @KNOWNOW_LICENSE_END@
 * 
 **/

#include <EXTERN.h>
#include <perl.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

#ifdef __cplusplus
#  define EXTERN_C extern "C"
#else
#  define EXTERN_C extern
#endif

EXTERN_C void boot_DynaLoader (CV* cv);

EXTERN_C void
xs_init()
{
    char *file = __FILE__;
    /* DynaLoader is a special case */
    newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
}

int main(int argc, char **argv, char **env)
{
    char *embed_args[] =
        {
            "",
            "-w",
            "PubSubService.cgi",
            NULL
        };
    PerlInterpreter *my_perl;
    size_t content_buffer_length = 1;
    char *content_buffer = (char *) malloc(content_buffer_length + 1);
    STRLEN content_length = 0;

    if (! content_buffer)
    {
        perror("malloc");
        return 1;
    }

    do
    {
        size_t nread;

        if (content_buffer_length == (size_t) content_length)
        {
            content_buffer_length <<= 1;
            if (! (content_buffer = (char *)
                   realloc(
                       (void *) content_buffer,
                       content_buffer_length + 1)))
            {
                perror("realloc");
                return 1;
            }
        }

        nread =
            fread(
                (void *) (content_buffer + content_length),
                sizeof(char),
                content_buffer_length - (size_t) content_length,
                stdin);

        if (! nread && ferror(stdin))
        {
            perror("stdin");
            return 1;
        }

        content_length += nread;
    }
    while (! feof(stdin));

    /* just to be polite, we leave enough space in content_buffer for
     * an extra NUL at the end, even though Perl ignores that NUL and
     * allows NULs embedded in the middle of strings */

    content_buffer[content_length] = '\0';

#if 0
    fprintf(
        stderr,
        "stdin: read %lu byte(s) (%lu-byte buffer)\n",
        (unsigned long) content_length,
        (unsigned long) content_buffer_length);
#endif

    my_perl = perl_alloc();
    perl_construct(my_perl);
    perl_parse(my_perl,
               xs_init,
               sizeof(embed_args)/sizeof(*embed_args) - 1,
               embed_args,
               NULL);
#ifdef PERL_EXIT_DESTRUCT_END
    PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
#endif

    /*** skipping perl_run() ***/

/*

    # $SERVER is the SOAP interface URI (i.e. something which runs
    # this script, minus query string).  This is written into the
    # autogenerated WSDL as the HTTP transport endpoint URI.

    if ($ENV{KN_SERVER}) { $SERVER = $ENV{KN_SERVER}; }

    # $SERVER_LOOPBACK is the PubSub Server URI as seen by this
    # script; this will be seen by clients from time to time, but only
    # embedded in "opaque" strings, e.g. route URIs.

    if ($ENV{KN_SERVER_LOOPBACK}) { $SERVER_LOOPBACK = $ENV{KN_SERVER}; }

*/

    if (getenv("KN_SERVER"))
    {
        SV* sv = get_sv("SERVER", TRUE);

        sv_setpv(sv, getenv("KN_SERVER"));
    }

    if (getenv("KN_SERVER_LOOPBACK"))
    {
        SV* sv = get_sv("SERVER_LOOPBACK", TRUE);

        sv_setpv(sv, getenv("KN_SERVER_LOOPBACK"));
    }

/*

    my ($status, $responseHeaders, $responseContent) =
        handle_string({ "do_method" => "soap" }, $content, "POST", "/");

*/

    {
        dSP;
        I32 retval_size;

        ENTER;
        SAVETMPS;

        /* pass arguments on perl stack */

        PUSHMARK(SP);

        /* { "do_method" => "soap" } */
        {
            HV *headers = newHV();

            hv_store_ent(headers,
                         newSVpv("do_method", 0),
                         newSVpv("soap", 0),
                         0);
            XPUSHs(sv_2mortal(newRV_noinc((SV *) headers)));
        }
        /* $content */
        XPUSHs(sv_2mortal(newSVpvn(content_buffer, content_length)));
        /* "POST" */
        XPUSHs(sv_2mortal(newSVpv("POST", 0)));
        /* "/" */
        XPUSHs(sv_2mortal(newSVpv("/", 0)));

        PUTBACK;

        retval_size =
            call_pv("handle_string", G_EVAL | G_ARRAY);

        SPAGAIN;

        /* check $@ for errors */
        if (SvTRUE(ERRSV))
        {
            STRLEN n_a;

            /* $@ in an array context implies no items on the stack */
            fprintf(stderr,
                    "NON-FATAL SOAP ERROR: %s\n", SvPV(ERRSV, n_a));
        }
        else
        {
            if (retval_size != 3)
            {
                fprintf(stderr,
                        "NON-FATAL SOAP ERROR: handle_string returned %ld item(s)\n",
                        (long int) retval_size);
                while (retval_size --) POPs;
            }
            else
            {
                SV *retval[3];

                /* get return values from perl stack */
                retval[0] = POPs;
                retval[1] = POPs;
                retval[2] = POPs;
                /* $status */
                {
                    STRLEN statusLength;
                    const char *status;

                    status = SvPV(retval[2], statusLength);
                    printf("Status: ");
                    fwrite(status, (size_t) statusLength, (size_t) 1, stdout);
                    printf("\r\n");
                }
                /* $responseHeaders */
                if (! SvROK(retval[1]) ||
                    SvTYPE(SvRV(retval[1])) != SVt_PVHV)
                {
                    fprintf(stderr,
                            "NON-FATAL SOAP ERROR: $responseHeaders is not a hashref\n");
                }
                else
                {
                    HV *responseHeaders = (HV *) SvRV(retval[1]);
                    I32 numResponseHeaders;

                    numResponseHeaders = hv_iterinit(responseHeaders);
                    while (numResponseHeaders --)
                    {
                        char *key;
                        I32 keyLength;
                        SV *valueSV;
                        const char *value;
                        STRLEN valueLength;

                        valueSV = hv_iternextsv(responseHeaders, &key, &keyLength);
                        fwrite(key, (size_t) keyLength, (size_t) 1, stdout);
                        printf(": ");
                        value = SvPV(valueSV, valueLength);
                        fwrite(value, (size_t) valueLength, (size_t) 1, stdout);
                        printf("\r\n");
                    }
                }
                /* $responseContent */
                {
                    STRLEN responseContentLength;
                    const char *responseContent;

                    responseContent = SvPV(retval[0], responseContentLength);
                    printf("\r\n");
                    fwrite(responseContent, (size_t) responseContentLength, (size_t) 1, stdout);
                    fflush(stdout);
                }
            }
        }

        PUTBACK;

        FREETMPS;
        LEAVE;

    }

    perl_destruct(my_perl);
    perl_free(my_perl);

    free((void *) content_buffer);

    return 0;
}
