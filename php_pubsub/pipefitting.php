<?php

# pipefitting.php - Network Pipe Fitting for PHP

# Copyright 2003 KnowNow, Inc.  All Rights Reserved.
#
# @KNOWNOW_LICENSE_START@
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in
# the documentation and/or other materials provided with the
# distribution.
#
# 3. The name "KnowNow" is a trademark of KnowNow, Inc. and may not
# be used to endorse or promote any product without prior written
# permission from KnowNow, Inc.
#
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL KNOWNOW, INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# @KNOWNOW_LICENSE_END@

$RCSID = '$Id: pipefitting.php,v 1.3 2003/05/06 02:10:06 ifindkarma Exp $';

if (! defined("PIPEFITTING_PHP_INCLUDED"))
{
    define("PIPEFITTING_PHP_INCLUDED", 1);

    include("pubsublib.php");
    include("eventloop.php");

    # A pipe fitting is one end of a pipe.
    #
    # This API largely uses explicit continuation-passing style, which
    # makes code using it somewhat less readable.
    #
    # insock and outsock are normally the same, but don't have to be; the
    # pipe fitting reads from insock when data is available, and calls one
    # of onEOF, onError, and onData, depending on whether it just got
    # an end-of-file condition, an error, or some data.
    #
    # The pipe fitting also calls onError when writing to its outsock
    # yields an error; the string $why is used to tell the error handler
    # whether it was a read error ('read') or a write error ('write').
    #
    # When you finish_writing(), then when any buffered data has been
    # written, the pipe fitting will try to shutdown() its outsock
    # with SHUT_WR.  If that fails with ENOTSOCK, it will close() its
    # outsock.
    #
    # A pipe fitting gets "closed" when any of the following things happen:
    #
    # - it gets a read or write error (including EAGAIN, EWOULDBLOCK, and EINTR)
    # - it close()s its outsock, as described above
    # - it has both read an EOF from its insock and finish_writing()ed.

    # nonblocking, buffered bidirectional I/O (tcp, etc.)
    class PipeFitting
    {
        # Each pipe fitting has a handler object associated with it which
        # handles events generated by the pipe fitting.
        var $_handlers;

        var $_evl;
        var $_outbuf;
        var $_insock;
        var $_outsock;

        # booleans:
        var $_connected; # have we successfully read or written any data?
        var $_finished_writing; # is no more data to be written to us?
        var $_output_shutdown; # have we shutdown or closed outsock?
        var $_read_eof; # have we read an EOF or error on insock?
        var $_closed; # have we called the close callback?

        # used for reference verification
        var $_refs;

        # return string representation for debugging
        function repr()
        {
            eval(PUBSUB_MUTATE);
            $str =
                "PipeFitting ($this) {\n" .
                "   _evl: " . kn_toSource($this->_evl) . "\n" .
                "   _outbuf: " . kn_toSource($this->_outbuf) . "\n" .
                "   _insock: " . kn_toSource($this->_insock) . "\n" .
                "   _outsock: " . kn_toSource($this->_outsock) . "\n" .
                "   _handlers: " . kn_toSource($this->_handlers) . "\n" .
                "   _connected: " . kn_toSource($this->_connected) . "\n" .
                "   _finished_writing: " . kn_toSource($this->_finished_writing) . "\n" .
                "   _closed: " . kn_toSource($this->_closed) . "\n" .
                "   _read_eof: " . kn_toSource($this->_read_eof) . "\n" .
                "   _output_shutdown: " . kn_toSource($this->_output_shutdown) . "\n" .
                "}";
            return $str;
        }

        # constructor
        function PipeFitting()
        {
            eval(PUBSUB_MUTABLE);
        }

        # initializer
        function init($evl, $insock, $outsock)
        {
            eval(PUBSUB_MUTATE);
            $this->_handlers =
                array('args' => array(), # additional args ", ..." for handlers

                      # called when the pipe fitting is connected.  This will happen
                      # immediately for file descriptors attached to pipes, files, and
                      # ttys; but for sockets, it may take a while. FIXME: right now,
                      # this won't fire immediately if no data is buffered to be sent
                      # over the connection and no data is sent from the other end.
                      'onConnect' => '', # closure($this, ...)

                      # called when the pipe fitting reads an EOF
                      'onEOF' => '', # closure($this, ...)

                      # called when the pipe fitting gets an error on read or write
                      # the 'connected' parameter specifies whether the pipe fitting
                      # has successfully written or read data; it's useful to be able
                      # to distinguish errors on the first read or write to a network
                      # connection from errors on later reads or writes, as the former
                      # generally indicate a problem connecting, while the latter
                      # generally indicate that the connection was closed after being
                      # opened
                      'onError' => '', # closure($this, 'read' | 'write', $this->connected, ...)

                      # called when the pipe fitting receives data
                      'onData' => '', # closure($this, $data, ...)

                      # called when both the inbound and outbound parts of the pipe
                      # fitting are closed.  None of the PipeFitting code will ever
                      # touch the pipe fitting after this point.
                      'onClose' => '' # closure($this, ...)
                      );

            $this->_outbuf = "";
            $this->_insock = $insock;
            $this->_outsock = $outsock;
            $this->_connected = false;
            $this->_finished_writing = false;
            $this->_output_shutdown = false;
            $this->_read_eof = false;
            $this->_closed = false;
            $this->_evl = $evl;
            $this->_wrapOnReadable = PUBSUB_NULL;
            $this->_wrapOnWritable = PUBSUB_NULL;

            $this->_wrapOnReadable = new WrapOnReadable($this);
            $this->_wrapOnWritable = new WrapOnWritable($this);

            # making ttys nonblocking on Solaris is likely to cause you to be
            # spuriously logged out when this program exits or gets suspended.
            if (!@posix_isatty($insock)) socket_set_nonblock($this->_insock);
            if (!@posix_isatty($outsock)) socket_set_nonblock($this->_outsock);

            $this->_evl->setInterestOnReadable($this->_insock,
                                               $this->_wrapOnReadable);
        }

        function _call_close_callback()
        {
            eval(PUBSUB_MUTATE);
            if (! $this->_closed)
            {
                $this->_closed = true;
                kn_apply($this->_handlers['onClose'],
                         array_merge(array($this),
                                     $this->_handlers['args']));
            }
        }

        # Returns a pointer to the handlers array for a pipe fitting;
        # you can fill this struct with your handlers to change the
        # behavior of the pipe fitting.
        function getHandlers()
        {
            eval(PUBSUB_MUTATE);
            return $this->_handlers;
        }

        function setHandlers($handlers, $args = PUBSUB_NULL)
        {
            eval(PUBSUB_MUTATE);
            if ($args)
            {
                $this->_handlers['args'] = $args;
            }
            reset($handlers);
            while (list($name, $handler) = each($handlers))
            {
                $this->_handlers[$name] = $handler;
            }
        }

        # like write(2), returns number of bytes written on success or -1 on
        # failure; running out of buffer space is considered failure.
        function write($data)
        {
            eval(PUBSUB_MUTATE);
            if ($this->_finished_writing)
            {
                #errno = EBADF;  # as if we were writing on a closed fd
                return -1;
            }
            $this->_outbuf .= $data;
            if (strlen($this->_outbuf))
            {
                # XXX: check for failure?
                $this->_evl->setInterestOnWritable($this->_outsock,
                                                   $this->_wrapOnWritable);
            }
            return strlen($data);
        }

        # call this to indicate that you are not going to write any more on
        # the pipe; relays this to the other end if possible and returns 1 on
        # success.
        function finish_writing()
        {
            eval(PUBSUB_MUTATE);
            $this->_finished_writing = true;
            $this->_shutdown_if_necessary();
            return 1;
        }

        # call this if you want to invalidate the pipe fitting
        function destroy()
        {
            eval(PUBSUB_MUTATE);
            $this->_evl->clearInterestOnReadable($this->_insock);
            if ($this->_insock != $this->_outsock)
            {
                @socket_close($this->_insock);
            }
            $this->_read_eof = true;

            $this->_evl->clearInterestOnWritable($this->_outsock);
            @socket_close($this->_outsock);
            $this->_output_shutdown = true;
            $this->_finished_writing = true;

            $this->_call_close_callback();
        }

        function _shutdown_if_necessary()
        {
            eval(PUBSUB_MUTATE);
            if (! $this->_output_shutdown and
                $this->_finished_writing and
                strlen($this->_outbuf) == 0)
            {
                # SHUT_WR is 1
                $rv = @socket_shutdown($this->_outsock, 1);
                $this->_output_shutdown = true;
                if (kn_isEqualTo($rv, false))
                {
                    if (socket_last_error() == SOCKET_ENOTSOCK)
                    {
                        @socket_close($this->_outsock);
                    }
                }
                if ($this->_read_eof)
                {
                    $this->destroy();
                }
            }
        }

        # called after errors have happened
        function error($why)
        {
            eval(PUBSUB_MUTATE);
            if (!$this->_closed)
            {
                kn_apply($this->_handlers['onError'],
                         array_merge(array($this, $why, $this->_connected),
                                     $this->_handlers['args']));
            }
            $this->destroy();
        }

        # XXX: at present this doesn't get called until some data makes its
        # way over the socket.  
        #
        # This is fixable in a couple of ways, the simplest of which is to
        # check the socket for writability until it's connected, and then use
        # getsockopt with SO_ERROR to see if the socket is connected or
        # broken.  If getsockopt gives us ENOTSOCK, we can figure we're
        # already connected.  This is reported to work at least on Solaris,
        # Linux, and BSD (UNIX Network Programming, Vol. 1, 2nd Ed., section
        # 15.4).
        # 
        # Another possibility would be to check the socket for writability
        # until it's connected, then use poll() or select() to see if the
        # same file descriptor is also readable; if so, we should invoke the
        # read callback, which will either read data or an EOF or get an
        # error; but if the socket is not readable, we know we have
        # successfully connected. 
        function _note_is_connected()
        {
            eval(PUBSUB_MUTATE);
            if (!$this->_connected)
            {
                $this->_connected = 1;
                kn_apply($this->_handlers['onConnect'],
                         array_merge(array($this),
                                     $this->_handlers['args']));
            }
        }

        function onReadable()
        {
            eval(PUBSUB_MUTATE);
            $inbuf = "";
            # random magic number shows up in truss output
            $read_size = 3202;
            $inbuf = @socket_read($this->_insock, $read_size);
            if (kn_isEqualTo($inbuf, false))
            {
                if (socket_last_error() == SOCKET_EAGAIN or
                    socket_last_error() == SOCKET_EWOULDBLOCK or
                    socket_last_error() == SOCKET_EINPROGRESS)
                {
                    # don't worry about it
                }
                else
                {
                    $this->error('read');
                }
            }
            else
            {
                $inbuf = strval($inbuf);
                if (strlen($inbuf) == 0)
                {
                    $this->_note_is_connected();
                    kn_apply($this->_handlers['onEOF'],
                             array_merge(array($this),
                                         $this->_handlers['args']));
                    $this->_evl->clearInterestOnReadable($this->_insock);
                    $this->_read_eof = 1;
                    if ($this->_output_shutdown) $this->destroy();
                }
                else
                {
                    $this->_note_is_connected();
                    kn_apply($this->_handlers['onData'],
                             array_merge(array($this, $inbuf),
                                         $this->_handlers['args']));
                }
            }
        }

        function onWritable()
        {
            eval(PUBSUB_MUTATE);
            $rv = @socket_write($this->_outsock, $this->_outbuf);
            if (kn_isEqualTo($rv, false))
            {
                if (socket_last_error() == SOCKET_EAGAIN or
                    socket_last_error() == SOCKET_EWOULDBLOCK or
                    socket_last_error() == SOCKET_EINPROGRESS)
                {
                    # don't worry about it */
                }
                else
                {
                    $this->error('write');
                }
            }
            else
            {
                # XXX: potentially inefficient */
                $this->_outbuf = substr($this->_outbuf, intval($rv));
                $this->_note_is_connected();
            }
            if (!strlen($this->_outbuf))
            {
                $this->_evl->clearInterestOnWritable($this->_outsock);
                $this->_shutdown_if_necessary();
            }
        }

    }

    if (getenv("SCRIPT_FILENAME") and
        kn_fileIsEqualTo(__FILE__,
                         getenv("SCRIPT_FILENAME")))
    {
        header("Content-Type: text/html; charset=utf-8");

        ?><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
            <html>
            <head>
            <?php

        if (kn__gpc("show_source", false, array("_GET")))
        {
            ?><title><?php echo kn_htmlEscape(__FILE__); ?></title><?php
            show_source(__FILE__);
            exit;
        }

        ?>
            <title>Network Pipe Fitting for PHP</title>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
            </head>
            <h1 align="center">Network Pipe Fitting for PHP</h1>
            <br />
            <p>Not much here yet...</p>
            <br />
            <?php

        function _pipefitting_unitTest()
        {
            ?>
                <h2>Unit Tests</h2>
                <?php

            class _pipefitting_unitTestSuite
            {
                var $allTests;
                function _pipefitting_unitTestSuite()
                {
                    $this->$allTests = array();
                }
                function runTests()
                {
                    $array = $this->allTests;
                    ?><p>Running <?php
                    echo kn_htmlEscape(count($array));
                    ?> Test(s)...</p><?php
                    ?><ol><?php
                    while (list($name, $closure) = each($array))
                    {
                        ?><li><?php
                        echo "\n" . kn_htmlEscape($name) . ":\n";
                        flush();
                        $result = kn_apply($closure, array());
                        if (! $result)
                        {
                            print "OK";
                        }
                        else
                        {
                            print "FAILED, " . $result;
                        }
                        ?></li><?php
                    }
                    ?></ol><?php
                    ?><p>Done.</p><?php
                }
                function defineTest($name, $closure)
                {
                    $this->allTests[$name] = $closure;
                }
            }
            $s = new _pipefitting_unitTestSuite;

            # BEGINNING OF TESTS

            $s->defineTest("nop", "test_nop");
            function test_nop()
            {
            }

            # END OF TESTS

            $s->runTests();
        }

        _pipefitting_unitTest();

        ?>
            <hr size="1" />
            <p align="right" style="margin-top: 0px">You may find the <a
            href="<?php echo kn_htmlEscape(kn__gpc('PHP_SELF', false, array('_SERVER'))) . '?show_source=1'; ?>"
            >PHP source for this application</a> instructive.<br />
            Current <a href="http://www.php.net/" target="_blank">PHP</a> version:
            <?php echo kn_htmlEscape(phpversion()); ?></p>
            </body>
            </html>
            <?php
    }

} # ! defined("PIPEFITTING_PHP_INCLUDED")

?>
